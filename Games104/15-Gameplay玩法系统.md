## 15-Gameplay
Day2023/09/25

### 1-Gameplay的课程框架
![image](./15-Gameplay01/01.png)</p>
分为传统的Gameplay机制和AI系统。
![image](./15-Gameplay01/02.png)</p>
一个玩法回合游戏里，gameplay的工程师要和素有环节结合，所以gameplay的工程师一般是一个杂学家。
![image](./15-Gameplay01/03.png)</p>
而且Gameplay有很多分支，一个游戏里可以有格斗场景 也可以有大牌场景，有各种场景混合在一起。
![image](./15-Gameplay01/04.png)</p>
像堡垒之夜，一个系统就只需要两个月就整出来了，是一个非常迅猛的过程。所以GamePlay是很忙碌很辛苦的，因为要一直跟随着设计师的想法来迭代。因为需要支持快速迭代的功能。所以GamePlay要杂学且迅猛

### 2-事件机制
![image](./15-Gameplay01/05.png)</p>
事件机制的GameObject之间是需要能talk的，所以要有一个事件机制。
事件机制的设计模式是一个Publish-subscribe Pattern的设计模式；订阅者模式。</br>

发布-订阅模式（Publish-Subscribe Pattern，又称 Pub-Sub Pattern）是一种常见的消息传递模式，主要用于处理事件驱动的系统。它包括了三个主要的参与者：发布者（Publishers）、订阅者（Subscribers）和消息队列或者消息中间件。

以下是发布-订阅模式的基本工作流程：

发布者（Publishers）：发布者负责创建和发布消息。在发布-订阅模式中，发布者并不会直接发送消息给特定的接收者。相反，它只是将消息发布出去，然后由消息系统决定需要将这些消息传送给哪些订阅者。

订阅者（Subscribers）：订阅者订阅他们感兴趣的消息类型。当这些消息被发布时，订阅者就会收到这些消息。订阅者不需要知道是哪个发布者发布的消息。

消息队列或消息中间件（Event Dispatcher）：这是一个中间层，负责存储和转发发布者发布的消息。这个中间层知道哪些订阅者订阅了哪些消息，并将消息正确地传送给相应的订阅者。

这种模式的主要优点是它支持松耦合和动态的网络架构，这意味着发布者和订阅者可以独立地添加或删除，而不会影响到系统的其他部分。这使得系统可以更容易地扩展和修改。

![image](./15-Gameplay01/06.png)</br>


订阅者模式的三个Key Components：

回调注册（Callback Registration）是一种常见的编程模式，主要用于事件驱动的编程或异步编程。在这种模式中，一个函数（称为回调函数）被传递给另一个函数（称为高阶函数）作为参数。当特定事件或条件发生时，高阶函数将调用这个回调函数。

以下是回调注册的基本工作流程：

定义回调函数：首先，你会定义一个函数，这个函数将在特定的事件或条件发生时被调用。这个函数称为回调函数。

注册回调函数：然后，你将这个回调函数作为参数传递给另一个函数或方法。这个过程通常被称为回调函数的注册。

触发事件：当特定的事件或条件发生时，注册的回调函数就会被触发（即被调用）。

这里的重点是：在 main 函数中，greet 函数被传递给 registerCallback 函数作为参数。在 C++ 中，你可以直接使用函数名来获取这个函数的函数指针。所以，callback(name); 这行代码实际上就是在调用 greet 函数。由于 callback 指向 greet 函数，所以这行代码的效果就是打印出 "Hello, Alice"。

在游戏里的使用主要是事件驱动的编程：在图形用户界面（GUI）编程或游戏编程中，回调函数常用于处理用户的输入事件，如点击、按键等。你可以注册一个回调函数，当特定的事件发生时这个函数就会被调用。

```cpp
#include <iostream>

// 定义回调函数
void greet(const std::string& name) {
    std::cout << "Hello, " << name << std::endl;
}

// 注册回调函数
void registerCallback(void (*callback)(const std::string&)) {
    std::string name = "Alice";
    callback(name);
}

int main() {
    // 注册并调用回调函数
    registerCallback(greet);  // 输出: "Hello, Alice"
    return 0;
}
```

![image](./15-Gameplay01/07.png)</br>

我们可以通过枚举的类型来定义event；
![image](./15-Gameplay01/08.png)</br>

Gameplay里最简单的思想是，每一个event都去写一个类，程序员定义每一个event的各种的属性。但是hardcode是不可取的，因为event的各个属性应该是设计师定义的，应该是允许editable的，所以就需要有一个反射机制？

来自GPT，解决问题的方法可能如下：

数据驱动设计是一种让游戏逻辑由数据而非硬编码来驱动的方法。在这种模式中，事件的属性可以存储在一个数据文件（如 JSON、XML 或数据库）中，然后在游戏运行时动态地加载和应用这些属性。这样，游戏设计师就可以通过简单地修改数据文件来改变事件的行为，而无需修改和重新编译代码。

脚本语言（如 Python、Lua）也常被用于游戏开发，因为它们通常比静态类型语言（如 C++）更灵活和易于修改。你可以用脚本语言来编写游戏逻辑和事件处理代码，然后在游戏运行时解释和执行这些脚本。这样，游戏设计师就可以通过修改脚本来改变事件的行为，甚至可以在游戏运行时动态地加载和执行新的脚本。

反射是一种让程序能够检查和修改其自身结构和行为的能力。在支持反射的编程语言（如 Java、C#）中，你可以在运行时动态地创建对象、调用方法、修改字段等。这样，你就可以根据数据文件或脚本中的信息来动态地创建和配置事件，而无需为每个事件硬编码一个类。然而，需要注意的是，反射通常会带来一定的性能开销，并且可能会使代码更难理解和维护。

另外也可以用dll的方式，DLL（动态链接库，Dynamic-Link Library）是一种包含可执行代码和/或数据的二进制文件，它可以在运行时被一个或多个程序动态地加载和链接。DLL 是在 Microsoft Windows 中使用的一种共享库的实现方式，类似的概念在 Unix-like 系统中被称为共享对象（SO）。

DLL 可以提供一种可扩展性的解决方案，因为它允许你将代码分割成多个独立的、可动态加载的模块。这意味着你可以在不修改或重新编译主程序的情况下添加、更新或删除这些模块。这对于游戏开发来说是非常有用的，因为它可以使你更容易地添加新的事件、特性或其他游戏元素。

例如，你可以定义一个事件接口，并在一个或多个 DLL 中实现这个接口，每个 DLL 代表一种特定类型的事件。然后，你可以在游戏运行时动态地加载这些 DLL，并使用其中的事件类来创建和处理事件。这样，当你要添加新的事件类型时，你只需要编写一个新的 DLL，而无需修改和重新编译主程序。

![image](./15-Gameplay01/09.png)</br>
![image](./15-Gameplay01/10.png)</br>

callback的另一个名称叫invoke，叫触发或者激活，更贴切一点。当有一个event来了之后，就触发一个处理方法。
![image](./15-Gameplay01/11.png)</br>

回调函数的注册和执行，其实是分开的，在这个过程里就会出各种各样的问题；包括物体的生命周期和callback的安全性。
![image](./15-Gameplay01/12.png)</br>

这里举一个例子，就是一个伤害已经触发了，但是在上一帧，应该被伤害的物体已经被销毁了，这个时候就会出问题。
![image](./15-Gameplay01/15.png)</br>

所以引进了一些概念。</br>
![image](./15-Gameplay01/16.png)</br>
强引用，被引用的物体要是还被引用着，就不能被删除，就像shared pointer要是还被week pointer引用着就不能被删除一个道理。会保证整个引用的安全性，但是也会产生冗余导致内存占用越来越大。</br>
![image](./15-Gameplay01/17.png)</br>
弱引用，week reference。就是在调用之前需要去检查一下引用的这个对象还是否存在，会让释放变得轻松一点。

strong和week reference都是非常重要的方式。callback其实week reference用的多一点。

![image](./15-Gameplay01/18.png)</br>
然后就是EventDispatch，需要根据消息的种类去分发，但是这样的分发效率会非常非常低下。是M * N * K的复杂度，会挺满的。

![image](./15-Gameplay01/19.png)</br>
在事件分发（Event Dispatch）中，Immediate 机制是指当一个事件产生时，立即执行该事件的处理函数，而不是将事件放入事件队列等待后续处理。

举个例子，假设我们有一个点击按钮的事件。在 Immediate 机制下，当用户点击按钮时，相关的事件处理函数（例如按钮点击的回调函数）会立即执行。这意味着在用户的点击动作完成后，事件处理函数已经执行完毕。

这种机制的优点是响应时间快，因为事件处理函数是在事件产生的那一刻立即执行的。但是，这也可能带来一些问题。例如，如果事件处理函数的执行时间过长，它可能会阻塞其他的事件或者主线程的执行。另外，由于事件处理函数是立即执行的，所以如果在事件处理函数中产生了新的事件，那么这个新的事件可能会在当前事件处理完成之前就被处理，这可能会导致事件的处理顺序和预期不一致。

为了阻塞线程和顺序不一致的问题，很多系统会使用事件队列和事件循环的机制来处理事件。在这种机制下，当一个事件产生时，它会被放入事件队列。然后，事件循环会逐个取出事件并执行其处理函数。这样可以保证事件的处理顺序，也可以避免长时间的事件处理阻塞其他的事件或主线程。然而，这种机制的响应时间可能会比 Immediate 机制慢，因为事件的处理需要等待事件循环的调度。

![image](./15-Gameplay01/20.png)</br>
像这个手雷一层层往下的情况，其实就会有处理顺序的问题；

![image](./15-Gameplay01/21.png)</br>
这个是一个等待时间的问题，手雷炸之前需要有一个烟雾的效果，这个是非常费算力的，所有后续都要等待，导致帧率会突然不稳定。

![image](./15-Gameplay01/22.png)</br>
另外一个缺点是这个调用时一层套一层的，所以很难并行化。

![image](./15-Gameplay01/23.png)</br>
事件队列

在事件驱动的编程模型中，事件队列是一种数据结构，通常用于存储和管理在程序运行中产生的事件。这些事件可以是用户的行为（如点击、键盘输入等），或者是系统生成的（如定时器、网络请求等）。

当一个事件产生时，它不会立即被处理，而是被放入事件队列中。接着，程序通过一个被称为事件循环（Event Loop）的过程，从队列中取出并处理事件。事件循环会持续运行，等待新的事件进入队列，这样一来，每当事件进入队列，事件循环就会处理它。

下面是一个基本的事件队列和事件循环的工作过程：

1-事件发生，例如用户点击了一个按钮。</br>
2-应用程序将事件信息（如事件类型、发生时间、相关数据等）打包成一个事件对象，并将其加入到事件队列中。</br>
3-事件循环从事件队列中取出事件对象。</br>
4-事件循环调用与该事件对象相关的事件处理器（Handler）进行处理。这些处理器是在程序中预先定义好的，用于响应特定类型的事件。</br>
5-事件处理器完成对事件的处理后，事件循环继续从队列中取出下一个事件进行处理。</br>
6-如果事件队列空了，事件循环就会等待，直到新的事件进入队列。</br>

事件队列的使用有许多优点。首先，它能有效地管理事件，确保事件按照一定的顺序（通常是它们发生的顺序）被处理。其次，它使得事件的处理可以异步进行，使得程序在等待某些事件（如网络请求）的响应时，能够继续处理其他的事件。最后，通过适当地控制事件的处理，事件队列可以帮助避免程序的阻塞，从而提高程序的响应性和效率。

为什么event queue可以异步执行但是 immediate不行？

Immediate 机制是同步的，当事件发生时，事件处理函数会立即被调用并执行。这意味着主程序必须等待事件处理函数执行完成才能继续执行其他任务。这种方式的优点是可以立即响应事件，但如果事件处理函数执行时间较长，可能会导致主程序的其他部分被阻塞，影响程序的性能和响应性。

Event Queue 机制则是异步的，当事件发生时，它会被添加到事件队列中，然后主程序可以继续执行其他任务。事件循环会在后台不断地从事件队列中取出并处理事件。因此，即使事件处理函数的执行时间较长，也不会阻塞主程序的其他部分。这种方式的优点是可以提高程序的性能和响应性，但可能会稍微延迟处理事件，因为事件需要等待在事件队列中被事件循环取出。

![image](./15-Gameplay01/24.png)</br>

序列化 是将数据结构或对象状态转换为可以存储或传输的形式的过程。这种形式需要能在后续使用中被轻松读取（反序列化）。序列化后的数据可以写入磁盘，或者通过网络发送到其他机器。序列化的主要目的是保存对象的状态，或者在网络上发送对象。

反序列化 是将序列化的数据转换回其原始形式的过程。

其实在反射机制里的序列化是很好做的，因为我们已经知道了其大小；

![image](./15-Gameplay01/25.png)</br>
event在内存中存储的数据结构叫做 ring buffer；</br>
环形缓冲区（Ring Buffer），也被称为循环缓冲区（Circular Buffer），是一种先进先出（FIFO）的数据结构，它在处理流数据和实现数据缓存时非常有用。环形缓冲区的特点是，当它被填满后，新的元素将覆盖最早添加的元素。假设每一帧最多会存5000个或者1000个event，这样的好处就是不用再去申请新的内存了，当read指针和write指针重叠的时候就能知道此时已经满了。

![image](./15-Gameplay01/26.png)</br>
我们会根据event的类型，把不同类型的event给分发在不同的queue里。而且这样debug起来也会非常轻松且容易。所以在架设引擎event系统的时候需要分类；

![image](./15-Gameplay01/27.png)</br>
event queue的并行问题是会忽略本来按照顺序提交的命令，比如这里我们希望是先 effect再audio，他就直接并行了。所以有时候也要用immidate；

![image](./15-Gameplay01/29.png)</br>
这也是 Event Queue比 Immediate不好的地方，有时我们需要在同一帧内出效果，但是用event queue往往会拖到两到三帧之后。这是因为，事件循环通常是在每一帧（Frame）更新后运行一次，处理在上一帧中产生并添加到事件队列的事件。

具体来说，当一个事件发生时（比如用户的输入或系统发出的信号），这个事件首先会被添加到事件队列中。然后，事件循环需要等待到下一帧才开始处理事件队列中的事件。因此，处理这个事件的实际时间会比事件发生的时间晚一帧，这就是所谓的“一帧延迟”。

在许多情况下，这种一帧的延迟是可以接受的，因为在大多数现代系统中，帧率（Frame Rate）通常非常高（例如，60帧/秒），所以这种延迟通常只有几毫秒。然而，在需要高精度时间反馈的系统（例如，某些实时游戏或高频率的交互系统）中，这种延迟可能会成为问题。

为了减少或避免一帧延迟，可以采用一些策略，如优化事件处理的速度，以便在同一帧中处理更多的事件；或者使用其他并行或并发的技术，使得事件的处理可以在事件发生后立即进行，而不是等待到下一帧。然而，这些策略可能会增加系统复杂性，需要根据具体的应用和性能需求来权衡。

### 3-游戏的逻辑与脚本系统
逻辑的玩法系统，最简单就是用C++写死的，也是非常高效的。最大的问题就是，每次修改一点gameplay，就需要重新修改一次，问题最大的就是有bug的话，就很难更新。
![image](./15-Gameplay01/30.png)</br>
游戏能动态debug的方式叫做热更新，但是cpp就是难以热更新； 热更新（Hot Swapping）是一种在不停止或重新启动程序的情况下更新程序的技术。在许多实时系统或高可用性系统中，这种技术非常重要，因为这些系统不能承受长时间的停机时间。热更新在游戏开发、服务端开发等领域中尤其常见。
![image](./15-Gameplay01/31.png)</br>
而且最大的使用者，是设计师，他们需要去定义gameplay和游戏玩法。所以就需要有一个脚本语言，Scripting，很好上手，而且非常容易热更新；

Lua是一种高级的脚本语言，源于巴西，首次发布于1993年。Lua设计的目标是为了嵌入应用程序中，提供灵活的扩展和定制功能。因此，Lua是一种轻量级的语言，它只提供了一小组基本的功能，这些功能可以组合在一起以完成更复杂的任务。

以下是Lua的一些核心特性：

轻量级：Lua被设计为一种非常轻量级的语言。它的核心库非常小，且可以通过C API轻松地与C和其他语言进行交互。

可扩展：Lua提供了一种简单的方式来注册新的C/C++函数，这些函数可以作为Lua函数调用。这允许开发者将已有的C/C++代码库暴露给Lua，从而提供强大的功能。

动态类型：Lua是一种动态类型语言，这意味着你不必在声明变量时指定其类型。这使得编写代码更具灵活性，但也意味着必须更小心地处理类型错误。

基于表的数据结构：Lua的主要数据结构是"table"。这是一种关联数组类型，可以用来实现数组、集合、记录等各种数据结构。

支持协程（coroutines）：Lua支持协程，这是一种可以被挂起和恢复的轻量级线程。协程对于实现多任务编程和非阻塞I/O等功能非常有用。

Lua在许多领域都得到了广泛的应用，尤其在游戏开发中，许多游戏引擎（如Unity、Unreal Engine）和游戏（如World of Warcraft、Angry Birds）都使用Lua作为脚本语言。它也被用于嵌入式系统、图形应用、网络编程等多个领域。

举个例子，在写大型网络游戏的服务器端会比较有用，几百个进程和线程，某个服务crash，并不会使得本体也crash。
![image](./15-Gameplay01/33.png)</br>

脚本语言的运行时这样的：首先Script Text编译成一个Bytecode，然后在虚拟机上跑，有点事非常鲁棒性，缺点是不够高效。
![image](./15-Gameplay01/34.png)</br>

脚本语言就有很多很多逻辑，比如开宝箱，以及各种玩法，策划也可以写。我们需要理解脚本语言和引擎之间最难的是对象的管理。一些对象是给引擎管理，还是给脚本管理？比如一些npc。引擎是效率高的，但是由一些脚本玩法产生的对象的创建和管理可以交给脚本，然后引擎只是引用他们。
![image](./15-Gameplay01/35.png)</br>

然后object的生命周期管理，就可以交给GC，就是垃圾回收系统。 Garbage Collection，GC

垃圾收集是一种自动内存管理技术。它的工作原理是追踪哪些对象正在被使用，哪些对象没有被使用并且可以安全地删除。当一个对象不再被引用时，垃圾收集器就会认定这个对象是"垃圾"，并在适当的时候回收这个对象占用的内存。

例如，在Java和C#这样的语言中，垃圾收集器会自动管理内存，开发者不需要手动释放他们创建的对象。这样可以避免许多常见的内存管理问题，比如内存泄漏和悬挂指针。

然而，需要注意的是，不是所有的编程语言都有自动垃圾收集。例如，在C++中，开发者需要手动管理内存。如果开发者创建了一个对象但是忘记了删除它，那么这个对象就会一直占用内存，直到程序结束，这就是所谓的内存泄漏。

好处就是无脑的创建对象和使用，问题就是会很慢，要扫描所有的content的引用关系。要是重度的脚本类游戏，那就需要优化GC。

![image](./15-Gameplay01/36.png)</br>

引擎可以去调用脚本，然后把某个特定的component写成脚本，像unity一样。
![image](./15-Gameplay01/37.png)</br>

或者用脚本去调用引擎，把引擎当作是一个基本的库。这两种的方法都可以去思考。如果想走方案2，那需要设计引擎开放什么接口。
![image](./15-Gameplay01/39.png)</br>

脚本语言的热更新：

对于脚本语言来说，实现热更新相对容易，因为脚本语言通常是动态类型的，并且可以在运行时解释和执行。这意味着你可以在程序运行时加载新的脚本，或者更改现有的脚本，从而改变程序的行为。

例如，许多游戏使用Lua、Python或JavaScript等脚本语言来控制游戏逻辑。当需要更新游戏时，开发者可以简单地发送新的脚本给玩家的机器，然后游戏可以在运行时加载和执行这些新的脚本。

实现热更新的关键是要确保新的代码可以正确地与现有的系统状态交互。例如，如果新的代码需要访问某个对象，那么这个对象必须在新的代码执行时是可用的。为了达到这个目标，可能需要对程序的架构进行一些设计，以确保新旧代码之间的兼容性。

注意一点就是一些全局变量在热更新的时候就要做处理。会用十几种不同的语言，比如服务器用Go，脚本用Lua或者c#，一个现代游戏引擎是一个复合体，各种语言都要混合进行编程。

![image](./15-Gameplay01/40.png)</br>

脚本语言最大的诟病就是效率不高。有一种优化方法是 JIT；

编译型语言，如 C++、Java 或 Rust，需要在程序运行之前进行编译。在编译过程中，源代码会被转化为机器代码，然后由计算机硬件直接执行。编译型语言的优点是它们的执行速度通常比解释型语言快，因为它们直接运行机器代码，避免了解释的开销。但是，编译型语言的缺点是它们的开发和调试过程可能会比较复杂和耗时，因为任何代码更改都需要重新编译。

解释型语言，如 Python、Ruby 或 JavaScript，不需要预先编译。代码是在运行时由解释器逐行解释和执行的。解释型语言的优点是它们的开发和调试过程通常比编译型语言简单和快速，因为你可以立即看到代码更改的效果，无需重新编译。同时，许多解释型语言都是动态类型的，这使得它们在处理复杂的数据结构和算法时更具灵活性。然而，解释型语言的缺点是它们的执行速度通常比编译型语言慢，因为解释器需要在运行时将代码转化为机器可以执行的指令。

JIT 编译是一种折中的方案。它不是预先将所有代码编译成机器代码，而是在运行时，当代码被执行时，才进行编译。一旦某段代码被编译成机器代码，它就可以被快速地重复执行，而无需再次解释。这种方法对于循环或频繁调用的函数特别有效，因为它们一旦被编译，就可以快速地重复执行。

JIT 编译的一个关键概念是 "热点" 代码识别。JIT 编译器会监视正在执行的程序，找出被频繁执行的代码段（"热点"），然后将它们编译成机器代码。这种方式使得编译的开销主要集中在最需要优化的代码段上。

需要注意的是，JIT 编译并不能总是提高程序的性能。例如，对于只执行一次的代码，JIT 编译可能会增加额外的开销。因此，是否使用 JIT 编译，以及如何使用，需要根据具体的应用和性能需求来决定。

![image](./15-Gameplay01/41.png)</br>

所以就要挑选正确的语言！
![image](./15-Gameplay01/42.png)</br>

像Lua的缺点就是没有很多拓展类库，但是极其轻量。

像python就有很好的拓展库，也有面向对象，但是很重。

![image](./15-Gameplay01/43.png)</br>

C#作为脚本语言有自己的优势，尽管 C# 通常被视为一种编译型语言，但其在某些上下文中也可以作为脚本语言使用，例如在 Unity 游戏引擎中进行游戏开发。以下是 C# 作为脚本语言的一些优势：

强类型和面向对象：C# 是一种强类型语言，这意味着类型检查在编译时进行，有助于提前发现并修复错误。此外，作为一种面向对象语言，C# 支持类和接口，使得代码重用和模块化更加容易。

集成开发环境（IDE）支持：C# 有强大的 IDE 支持，如 Visual Studio 和 JetBrains Rider，这些 IDE 提供了代码高亮、智能提示、调试和性能分析工具，大大提高了开发效率。

广泛的库和框架支持：C# 有许多高质量的库和框架，如 .NET Framework 和 .NET Core，为开发者提供了大量的功能。此外，作为 Unity 游戏引擎的默认脚本语言，C# 还提供了开发高质量游戏的强大工具。

跨平台能力：通过 .NET Core 和 Xamarin，C# 可以在多种平台上运行，包括 Windows、MacOS、Linux、iOS 和 Android。

JIT 编译和垃圾回收：C# 使用 JIT（Just-In-Time）编译，可以在运行时优化代码的性能。此外，C# 还有自动垃圾回收功能，可以帮助开发者管理内存。

良好的社区支持：C# 有一个活跃的开发者社区，这意味着你可以容易地找到教程、代码示例、库和问题解答。

### 4-可视化脚本
最大名鼎鼎的就是蓝图系统。主要是面向设计师和艺术家，让他们去编程的成本是非常的高。环
![image](./15-Gameplay01/44.png)</br>

这里就是把很多功能给打包在一起了。
![image](./15-Gameplay01/45.png)</br>

变量最核心的就是变量，变量的作用域，和变量的type；
![image](./15-Gameplay01/46.png)</br>

在蓝图里会用不同的管脚，就是电池接口的不同颜色来定义其不同的类型。所以不同的颜色就可以连接在一起了！
![image](./15-Gameplay01/47.png)</br>

语句或者表达式，都可以用加减乘除来完成。在所有的状态机类型，和蓝图里，都需要有一个.
![image](./15-Gameplay01/48.png)</br>

Ctrol Flow，就是for循环和if else之类的；
![image](./15-Gameplay01/50.png)</br>

实战中，很多的运算希望经常去调用它，也有很好的输入和输出。可以吧一些列的操作打包在一起，有执行入口和出口；
![image](./15-Gameplay01/51.png)</br>
![image](./15-Gameplay01/52.png)</br>

要是有类似于类的概念，就是整个 blueprint的概念；
![image](./15-Gameplay01/53.png)</br>

很多提示词功能，就是user friendly的；因为引擎本身就是一个生产力工具；
![image](./15-Gameplay01/54.png)</br>

可视化语言的debug就是迅速的有一个电池的高亮；
![image](./15-Gameplay01/55.png)</br>

在工程里的问题是： 要是几个人同时改这个蓝图，那merge是一个很大的问题。不过在图来说，添加删除和移动，那merge出来的语义就很难解释了。
![image](./15-Gameplay01/56.png)</br>

另一个大问题是，要是代码的分块性，和可读性，会变差。
![image](./15-Gameplay01/57.png)</br>

其实脚本和可视化的脚本是一个东西。完全可以吧可视化的脚本和脚本相互转换，
![image](./15-Gameplay01/58.png)</br>

双人成行，是一个非常非常好的3C系统。
![image](./15-Gameplay01/58.png)</br>

### 5-游戏性开发中的3C
Character Control and Camera
![image](./15-Gameplay01/59.png)</br>

3C 是体验系统的核心！怎么让角色动起来怎么战斗起来；
![image](./15-Gameplay01/60.png)</br>

我们会发现一个3A游戏里，移动的细节非常非常多！很多各种移动之间都需要动作的转换。
![image](./15-Gameplay01/61.png)</br>

角色也需要和各种场景来互动，需要和环境，和地面系统，还有产生的音效和不同的效果，包括物理系统要去模拟空气的flow。
![image](./15-Gameplay01/62.png)</br>

动作系统是很复杂的，点进去就能发现每一段就又是一个脚本系统。当我们在写一个好的游戏，他的character系统就需要内嵌大量的内容。
![image](./15-Gameplay01/63.png)</br>

ctrol的核心是处理各种各样的输入设备； 我们要把不同输入设备的input，变成各种各样的gameplay；一个好的gameplay系统的细节就特别多。
![image](./15-Gameplay01/64.png)</br>
需要魔鬼一般的细节；相机需要去变换，然后鼠标的移动也要转换成input；还需要一个小小的吸附系统，是一个很重要的aim assist， 对玩家很友好。
![image](./15-Gameplay01/65.png)</br>
![image](./15-Gameplay01/66.png)</br>

有很多手柄，还能给到feedback；然后鼠标键盘没有力反馈，就需要用rgb来做光和力的反馈；游戏和电影最大的区别就是有没有反馈的系统。
![image](./15-Gameplay01/67.png)</br>

不同的按钮，在不同的环境下是不一样的，所以用户的input，一定就是多态的。control系统是我们丝滑手感的由来。
![image](./15-Gameplay01/68.png)</br>

camera系统；
![image](./15-Gameplay01/69.png)</br>

其实相机很多时候就是和任务角色绑定在一起的，但一些高级的游戏，通常相机不是直接绑定在人物身后的。
![image](./15-Gameplay01/70.png)</br>

相机系统有个很著名的叫弹簧臂；来调整聚焦，和判断不能穿墙。
![image](./15-Gameplay01/71.png)</br>

还有一个Camera track，就是在不同模式下，Camera的不同位置；
![image](./15-Gameplay01/72.png)</br>

还有一个很重要的效果叫做抖屏，是增强游戏感的一大妙招；
![image](./15-Gameplay01/73.png)</br>
相机也会有自己的惯性和动态模糊等操作，对游戏的表现是极高的！

![image](./15-Gameplay01/74.png)</br>

3C对那么多游戏都重要，主要是因为这三个点对游戏的表现是极其重要的！这也是gameplay系统很美妙的东西。

![image](./15-Gameplay01/75.png)</br>
可是化的脚本，一开始就是用于制作原型产品。
